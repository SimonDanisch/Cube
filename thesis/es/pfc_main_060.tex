%
% RESULTADOS Y RENDIMIENTO
%
\chapter{
	Resultados y rendimiento
	\label{nombre_referencia_al_capitulo_060}
}

En este capítulo se pasarán a analizar los resultados obtenidos de la ejecución de los diferentes algoritmos de visualización, tanto en términos de rendimientos como de calidad del \emph{render} obtenido. Se empezará por los 4 métodos de rasterización: \textit{Sized-Fixed} (ver. \ref{ss_sized}), \textit{Image-aligned Squares} (ver. \ref{ss_image-aligned_squares}), \textit{Affinely Projected} (ver. \ref{ss_affinely}) y \textit{Perspective Correct} (ver.\ref{ss_perspective_correct}). Seguidamente se comentarán los resultados obtenidos de la comparación de los 4 sistemas de \textit{blending}: \textit{Flat} (ver. \ref{ss_flat}), \textit{Gouraud} (ver. \ref{ss_gouraud}), \textit{Phong} (ver. \ref{ss_phong}), \textit{Deferred} (ver. \ref{ss_deferred}) y la estabilidad de estos algoritmos en temas de iluminación.

\section[Preparación de la prueba] {Preparación de la pruebas}
Se dispuso del mismo equipo (las características se muestran en la tabla del \tablename~\ref{computer_specifications}) para la obtención de los datos necesarios con motivo de analizar el rendimiento que presentan los diferentes algoritmos mencionados anteriormente. Así mismo se dispuso de un conjunto de 6 modelos que fueron muestreados a diferentes densidades (ver la tabla del \tablename~\ref{models_specifications}).

\begin{table}
	\centering
	\begin{tabular}{l r}
		\toprule
		\textbf{Equipo de Test} \\\midrule
		CPU: & Intel Core i7-4930K \\
		Tarjeta Gráfica: & NVIDIA GTX 780Ti \\
		RAM: & 16 GB DDR3 a 2133 MHz \\
		HDD: & WD Caviar Black HDD \\
		SO: & Windows 7 \\
		\bottomrule
	\end{tabular}
	\caption {Resumen de las características del equipo de Test.}
	\label{computer_specifications}
\end{table}

\begin{table}
	\centering
	\begin{tabular}{l r}
		\toprule
		\textbf{Modelo} & \textbf{Número de puntos}\\\midrule
		Suzanne & 473672\\
		Head (Ten24) & 1223693 \\
		Dorna & 2585907 \\
		Dragon & 8628877 \\
		Happy Budha & 26519484 \\
		Lucy & 43982232 \\
		\bottomrule
	\end{tabular}
	\caption {Los modelos utilizados en el test.}
	\label{models_specifications}
\end{table}

El parámetro de rendimiento que se estudiará será el tiempo (en segundos) que se tarda en renderizar un \textit{frame}. El visualizador consta con un modo \textit{DEBUG} en el que automáticamente escribe en un \textit{log} los datos resultantes de la sesión. El formato de este \emph{log} consta de una línea con la cabecera en la que se resume el escenario actual de ejecución, al que siguen los tiempos medios resultantes de los últimos 25 \textit{frames}.
El \tablename~\ref{tab:formato} muestra un ejemplo de este formato.

\begin{table}
  \begin{lstlisting}[frame=single, basicstyle=\scriptsize]
CUBE | Sized-Fixed Points | Flat Shading | RGB | 6000 Points | 0 Lights | 640x480
0.0152009
0.016681
0.016721
0.016681

CUBE | Sized-Fixed Points | Flat Shading | RGB | 6000 Points | 0 Lights | 1920x1058
0.0144408
0.016641
0.016681
0.016641
0.016641
0.016681
  \end{lstlisting}
  \caption{Formato del fichero de texto con los \emph{logs} generados.}\label{tab:formato}
\end{table}

Con el objetivo de facilitar y agilizar todas las tareas relacionadas con el análisis de los datos obtenidos, se creó una herramienta para automatizar el análisis de este fichero \textit{log} y generar automáticamente las gráficas necesarias para su comprensión. El \tablename~\ref{tab:cli} muestra la interfaz en línea de comandos de esta herramienta.

\begin{table}
  \begin{lstlisting}[frame=single, basicstyle=\footnotesize]
  CUBE GRAPH GENERATOR

  USAGE: cubeGraphGen.py [options] logFile

  OPTIONS:
  -h        Display available options
  --help    Display available options
  -v        Run in verbose mode
  May the Force be with you :)
  \end{lstlisting}
  \caption{Herramienta de apoyo en línea de comandos implementada para automatizar la creación de gráficas de resultados a partir del análisis de las ejecuciones de las pruebas.}
  \label{tab:cli}
\end{table}

\section[Análisis de los métodos de rasterización] {Análisis de los métodos de rasterización}

Se renderizaron los 6 modelos mediante los 4 métodos de rasterización, sin filtro de antialiasing, iluminación o \textit{blending}. El resultado de este análisis lo podemos ver en la gráfica de la \figurename~\ref{figure_rasterization_graph}.

Se encontró que en cuanto aumentó notablemente el número de puntos a dibujar, el rendimiento del supuestamente más ligero de todos los algoritmos \textit{Sized-Fixed} cayó estrepitosamente, debido a que al tener el tamaño de punto definido de forma constante este estaría generando más fragmentos en comparación con los otros 3 que corrigen su tamaño en función de la profundidad y de la distancia con los n-vecinales.

Además, en comparación con los algoritmos que utilizan las normales para la representación, en el algoritmo \textit{Affinely Projected} al no poder hacer \textit{backface culling}\footnote{Técnica que consiste en eliminar del \emph{pipeline de render} las primitivas cuya normal apunta en dirección opuesta a la cámara, es decir, aquellas superficies que son vistas por detrás en lugar de frontalmente y, por lo tanto, no deberían tener influencia visual en el render (aunque sí en tiempo si no son eliminadas).} aumentan el número de puntos a mostrar aumentando el tiempo de \textit{render}.


\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{../figures/rasterization_graph.pdf}
	\caption{Gráfica comparativa de los 4 sistemas de rasterización.}
	\label{figure_rasterization_graph}
\end{figure}

Con respecto al aspecto visual (podemos ver un ejemplo comparando los cuatro algoritmos en las capturas de la \figurename~\ref{figure_rasterization_comparative}), encontramos que:
\begin{itemize}
	\item  El algoritmo \textit{Sized-Fixed} crea agujeros de forma incontrolable, ya que dependiendo de la distancia a la que en la que se encuentren los puntos, puede dar sensación de superficie cerrada o de nube dispersa.
	\item El algoritmo de \textit{Square Aligned} consigue cerrar la superficie pero deforma los contornos notablemente.
	\item El algoritmo \textit{Affinely Projected} da una sensación buena, pero da lugar a fallos con discos con ángulos perpendiculares al plano \textit{near} de la cámara. (como se muestra en la \figurename~\ref{figure_affinely_holes})
	\item El método de \textit{Perspective Correct} consigue mantener el contorno, además de evitar los agujeros de la anterior aproximación.
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{../figures/comparacion_raster.eps}
	\caption{Comparativa de los resultados de render. \textit{Sized-fixed} (\textbf{izquierda}), \textit{Square-aligned} (\textbf{centro izquierda}), \textit{Affinely} (\textbf{centro derecha}) y \textit{Perspective Correct} (\textbf{derecha}).}
	\label{figure_rasterization_comparative}
\end{figure}

\section{Análisis de los métodos de blending}

Se renderizaron los seis modelos de prueba mediante los cuatro métodos de \textit{blending}, sin filtro de \textit{antialiasing} ni iluminación. El resultado de este análisis lo podemos ver en la gráfica de la \figurename~\ref{figure_blending_graph}.

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{../figures/blending_graph.pdf}
	\caption{Gráfica comparativa de los 4 sistemas de blending.}
	\label{figure_blending_graph}
\end{figure}

Se concluyó que como se esperaba, el método de renderizado en un pase (sin \textit{blending}) alcanza mejores tiempos de \textit{render} en comparación con los otros tres algoritmos que constan de tres pases para su dibujado. Teniendo estos tres un resultado bastante similar y peor con respecto al \textit{Flat Shading}.

Comparando al acabado visual de los algoritmos (mostrado en la \figurename~\ref{figure_blending_comparative}) encontramos que:
\begin{itemize}
	\item \textit{Flat Shading} no elimina las discontinuidades consecuencia de la intersección y solape de los discos.
	\item \textit{Gouraud Shading} elimina las discontinuidades añadiendo cierto desenfoque en su acabado.
	\item \textit{Phong} como \textit{Deferred Shading} eliminan las discontinuidades, añadiendo mas definición que el anterior, puesto que se hace una interpolación de las normales. Siendo el resultado de estos dos métodos es prácticamente similar.
\end{itemize}

\subsection{Comparación de los sistemas de blending con puntos de luz}

Para esta prueba, los seis modelos fueron renderizados con los cuatro algoritmos de \textit{blending} sin antialiasing y bajo la influencia de diferentes conjuntos de luces radiales. Así, para la iluminación se contó con distintas disposiciones con un número de luces variable 0, 1, 3, 5, 7 o 9 luces radiales. Los resultados se muestran en las gráficas de las \figurename{s}~\ref{figure_blend_vs_light} y \ref{figure_blend_vs_light2}.

Analizando los resultados obtenidos, se puede concluir que la iluminación con \textit{Deferred Shading} es más estable ante un aumento en el número de puntos de luz de la escena. De esta forma se evidencia la superioridad de la iluminación por \textit{píxel} en contrapuesta con los algoritmos que iluminan por \textit{fragmento}.

\begin{figure}
  \centering
    \subcaptionbox{Flat Shading} {\includegraphics[width=0.9\columnwidth]{../figures/flat_graph.pdf}}\\[0.5cm]
    \subcaptionbox{Gouraud Shading} {\includegraphics[width=0.9\columnwidth]{../figures/gouraud_graph.pdf}}
    \caption{Comparación de los diferentes sistemas de blending, comparando luces con millones de puntos: flat y Gouraud.}
    \label{figure_blend_vs_light}
\end{figure}

\begin{figure}
  \centering
    \subcaptionbox{Phong Shading} {\includegraphics[width=0.9\columnwidth]{../figures/phong_graph.pdf}}\\[0.5cm]
    \subcaptionbox{Deferred Shading} {\includegraphics[width=0.9\columnwidth]{../figures/deferred_graph.pdf}} 
    \caption{Comparación de los diferentes sistemas de blending, comparando luces con millones de puntos: Phong y Deferred.}
    \label{figure_blend_vs_light2}
\end{figure}


%
% FIN DEL CAPÍTULO
%
