%
% VISUALIZACIoN DE NUBES DE PUNTOS
%
\chapter{
	Análisis y diseño de un visualizador
	\label{nombre_referencia_al_capitulo_040}
}

En este capítulo se presentará el resumen de diseño que se siguió en la creación del visualizador de nubes de puntos.


%
% SECCION - Técnicas de rasterización
%
\section[Análisis de requisitos]{
	Análisis de requisitos
	\label{s_analisis}
}

Ante la necesidad de un visualizador en el que poder probar los algoritmos que se iban a implementar, se pensó que sería buena idea el desarrollo de uno propio de manera que fuera simple, sencillo y fácilmente modificable. 

El visualizador tendría que cumplir los siguiente requisitos:
\begin{itemize}
	\item Tener una gestión de \textit{shaders} de manera que fuera sencillo compilar y enviar a \textit{GPU} estos programas, además de facilitar la incorporación de nuevos en el proyecto.
	\item Carga de modelos desde ficheros en disco.
	\item Un sistema para almacenar las nubes de puntos y poderlas enviar a \textit{GPU} para su dibujado. 
	\item Una cámara para moverse alrededor de los objetos cargados.
	\item Fuentes de luz para la iluminación de la escena.
	\item Un \textit{framebuffer} donde almacenar los resultados.
\end{itemize}

\subsection{Casos de uso}

Se establecerán los siguientes casos de uso (ver Figura \ref{figure_casos_de_uso}), siendo los más significativos:
\begin{itemize}
	\item La carga de modelos mediante ficheros externos (formatos .PLY o .PCD) destinados al almacenamiento de este tipo de datos.
	\item La opción para desactivar el color RGB de los puntos, de manera que sea mas claro evaluar si la reconstrucción de la superficie es correcta.
	\item La capacidad de moverse por el espacio tridimensional.
	\item Modificar el radio de los puntos manualmente o que el programa estipule un radio de manera automatica.
	\item Poder escoger entre los diferentes métodos de rasterización o \textit{blending} implementados para variar la visualización de la nube.
	\item Cambiar el sistema de iluminación.
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{../figures/casosdeuso.pdf}
	\caption{Casos de uso de la aplicación.}
	\label{figure_casos_de_uso}
\end{figure}


\section{Diagrama de clases}
Una vez definidos los requisitos, se pasó a diseñar un esqueleto el cual se podrá ver en el siguiente diagrama de clases (ver Figura \ref{figure_diagram_class}):
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{../figures/cubeUML.pdf}
	\caption{Diagrama de clases del visualizador de nubes de puntos.}
	\label{figure_diagram_class}
\end{figure}

La idea de tener un \textit{framebuffer} propio donde renderizar de manera separada (clase \textbf{FBO}), permitió independizar el visualizador de la librería que fue usada para la creación de ventanas en el Sistema Operativo\footnote{GLFW: http://www.glfw.org/}, de forma que en caso de necesitar cambiarla, esta escasa dependecia facilitaría la tarea.

La clase \textbf{Shader}, vendría a dar la solución al manejo de los \textit{vertex} y \textit{fragment shaders} en el visualizador, ofreciendo métodos para compilar y enviar estos programas a \textit{GPU}.

La clase \textbf{Models} será la encargada de almacenar los modelos que se carguen. Estos almacenarán los datos de la nube (posición, color, normal y radios).

El objetivo de la clase \textbf{VAO} será la de enviar la información de la nube de puntos al \textit{pipeline} y encargarse de reservar la memoria en la tarjeta gráfica.

La clase \text{Camera} viene a ser la implementación de todo lo explicado en la sección \ref{camera_model}, ofreciendo las matrices de transformación pertinentes y que serán necesarias para el render. En este caso el funcionamiento de la cámara es orbital, rotando alrededor de origen de coordenadas, pudiendo acercar o alejar la vista.

Se implementaron tres tipos diferentes de luz según su comportamiento: una luz orbital que gira alrededor de un eje, una luz que se denominó \textit{camera light} de forma que se podía fijar a una cámara para que iluminara desde su posición y otra estática con motivo de tener luces de relleno inmóbiles en la escena. Estas tres luces heredan de la superclase \textbf{Light}. 

La clase \textbf{Globals} nos permite almacenar variables donde almacenar las diferentes configuraciones que el usuario puede usar para ajustar la visualización a su gusto, además de registrar otra información relevante así como la posición del ratón, dimensiones de la ventana, título ...

%
% FIN DEL CAPÍTULO
%
